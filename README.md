# read_length_SV_discovery

This repository contains scripts used to assess the optimal and sufficient read length in long read sequencing data for structural variant (SV) discovery, using PacBio reads simulated using [simlord](https://bitbucket.org/genomeinformatics/simlord/) based on the [HG00733 assembly](https://www.pacb.com/press_releases/pacific-biosciences-releases-highest-quality-most-contiguous-individual-human-genome-assembly-to-date/) followed by alignment using [minimap2](https://github.com/lh3/minimap2) and structural variant calling using [Sniffles](https://github.com/fritzsedlazeck/Sniffles). Also used are [duphold](https://github.com/brentp/duphold) for filtering SVs (using coverage of flanking sequences), [mosdepth](https://github.com/brentp/mosdepth) (assessing the genome coverage), [SURVIVOR](https://github.com/fritzsedlazeck/SURVIVOR) (merging SV vcf files), [cyvcf2](https://github.com/brentp/cyvcf2) (parsing vcf files in Python) and [bcftools](https://github.com/samtools/bcftools) and [samtools](https://github.com/samtools/samtools) (handling vcf and bam files). Precision, recall and F-measure were calculated using a Python script [from an earlier project](https://github.com/wdecoster/nano-snakemake/blob/master/extra_scripts/precision-recall.py) and plotted using [matplotlib](https://github.com/matplotlib/matplotlib) and [pandas](https://github.com/pandas-dev/pandas). The truth set of structural variants was obtained by assembly-to-reference alignment using minimap2 followed by variant calling using paftools following the [syndip procedure](https://github.com/lh3/CHM-eval/tree/master/dip-call). Commands were parallelized using the amazing power tool [gnu parallel](https://www.gnu.org/software/parallel/).

This project was made a lot easier thanks to all developers for making nice software with great documentation!
